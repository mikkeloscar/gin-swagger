package node_pools

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"io"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/validate"
	"github.com/mikkeloscar/gin-swagger/api"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/mikkeloscar/gin-swagger/example/models"
)

//  executes the core logic of the related
// route endpoint.
func EndpointCreateOrUpdateNodePool(handler func(ctx *gin.Context, params *CreateOrUpdateNodePoolParams) *api.Response) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		// generate params from request
		params := &CreateOrUpdateNodePoolParams{}
		err := readRequest(ctx, params) // this change of params is just an idea, if it's too much work it is not worth it.
		if err != nil {
			errObj := err.(*errors.CompositeError)
			problem := api.Problem{
				Title:  "Unprocessable Entity.",
				Status: int(errObj.Code()),
				Detail: errObj.Error(),
			}
			ctx.Writer.Header().Set("Content-Type", "application/problem+json")
			ctx.JSON(problem.Status, problem)
			return
		}

		resp := handler(ctx, params) //handler is one method of the service interface
		switch resp.Code {
		case http.StatusNoContent:
			ctx.AbortWithStatus(resp.Code)
		default:
			ctx.JSON(resp.Code, resp.Body)
		}
	}
}

// CreateOrUpdateNodePoolParams contains all the bound params for the create or update node pool operation
// typically these are obtained from a http.Request
//
// swagger:parameters createOrUpdateNodePool
type CreateOrUpdateNodePoolParams struct {

	/*ID of the cluster.
	  Required: true
	  Pattern: ^[a-z][a-z0-9-:]*[a-z0-9]$
	  In: path
	*/
	ClusterID string
	/*Node pool to be created.
	  Required: true
	  In: body
	*/
	NodePool *models.NodePool
	/*Name of the node pool.
	  Required: true
	  Pattern: ^[a-z][a-z0-9-]*[a-z0-9]$
	  In: path
	*/
	NodePoolName string
}

//removed some stuff here :-)

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls

// TODO this description should contain the fact that it reads the request body from the gin context passed and the "return" value is inside the object on which it is called
func (o *CreateOrUpdateNodePoolParams) readRequest(ctx *gin.Context) error {
	var res []error
	formats := strfmt.NewFormats()

	rClusterID := []string{ctx.Param("cluster_id")}
	if err := o.bindClusterID(rClusterID, true, formats); err != nil {
		res = append(res, err)
	}

	if runtime.HasBody(ctx.Request) {
		var body models.NodePool
		if err := ctx.BindJSON(&body); err != nil {
			if err == io.EOF {
				res = append(res, errors.Required("nodePool", "body"))
			} else {
				res = append(res, errors.NewParseError("nodePool", "body", "", err))
			}

		} else {
			if err := body.Validate(formats); err != nil {
				res = append(res, err)
			}

			if len(res) == 0 {
				o.NodePool = &body
			}
		}

	} else {
		res = append(res, errors.Required("nodePool", "body"))
	}

	rNodePoolName := []string{ctx.Param("node_pool_name")}
	if err := o.bindNodePoolName(rNodePoolName, true, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateOrUpdateNodePoolParams) bindClusterID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	o.ClusterID = raw

	if err := o.validateClusterID(formats); err != nil {
		return err
	}

	return nil
}

func (o *CreateOrUpdateNodePoolParams) validateClusterID(formats strfmt.Registry) error {

	if err := validate.Pattern("cluster_id", "path", o.ClusterID, `^[a-z][a-z0-9-:]*[a-z0-9]$`); err != nil {
		return err
	}

	return nil
}

func (o *CreateOrUpdateNodePoolParams) bindNodePoolName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	o.NodePoolName = raw

	if err := o.validateNodePoolName(formats); err != nil {
		return err
	}

	return nil
}

func (o *CreateOrUpdateNodePoolParams) validateNodePoolName(formats strfmt.Registry) error {

	if err := validate.Pattern("node_pool_name", "path", o.NodePoolName, `^[a-z][a-z0-9-]*[a-z0-9]$`); err != nil {
		return err
	}

	return nil
}

// vim: ft=go
